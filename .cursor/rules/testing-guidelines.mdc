# Guidelines de Tests - CPBO

## Stratégie de Tests

### Pyramide de Tests
1. **Tests Unitaires** (70%) - Vitest + Vue Test Utils
2. **Tests d'Intégration** (20%) - Vitest
3. **Tests E2E** (10%) - Playwright

### Couverture Cible
- **Minimum** : 80% de couverture de code
- **Objectif** : 90% de couverture de code
- **Critique** : 100% pour les composants de formulaire

## Tests Unitaires (Vitest)

### Configuration
```javascript
// vitest.config.js
import { defineConfig } from 'vitest/config'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  test: {
    environment: 'jsdom',
    globals: true
  }
})
```

### Structure des Tests
```javascript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { mount } from '@vue/test-utils'
import Component from './Component.vue'

describe('Component', () => {
  let wrapper

  beforeEach(() => {
    wrapper = mount(Component)
  })

  it('should render correctly', () => {
    expect(wrapper.exists()).toBe(true)
  })

  it('should handle user interactions', async () => {
    await wrapper.find('button').trigger('click')
    expect(wrapper.emitted('click')).toBeTruthy()
  })
})
```

### Tests de Composants UI

#### Button Component
```javascript
describe('Button', () => {
  it('renders with default props', () => {
    const wrapper = mount(Button, {
      slots: { default: 'Click me' }
    })
    
    expect(wrapper.text()).toBe('Click me')
    expect(wrapper.classes()).toContain('btn-primary')
  })

  it('applies correct variant classes', () => {
    const wrapper = mount(Button, {
      props: { variant: 'secondary' }
    })
    
    expect(wrapper.classes()).toContain('btn-secondary')
  })

  it('emits click event when clicked', async () => {
    const wrapper = mount(Button)
    await wrapper.trigger('click')
    
    expect(wrapper.emitted('click')).toBeTruthy()
  })

  it('does not emit click event when disabled', async () => {
    const wrapper = mount(Button, {
      props: { disabled: true }
    })
    
    await wrapper.trigger('click')
    expect(wrapper.emitted('click')).toBeFalsy()
  })
})
```

#### Form Validation
```javascript
describe('ContactForm', () => {
  it('validates required fields', async () => {
    const wrapper = mount(ContactForm)
    
    await wrapper.find('button[type="submit"]').trigger('click')
    
    expect(wrapper.find('.error-message').exists()).toBe(true)
    expect(wrapper.find('.error').exists()).toBe(true)
  })

  it('validates email format', async () => {
    const wrapper = mount(ContactForm)
    
    await wrapper.find('#email').setValue('invalid-email')
    await wrapper.find('button[type="submit"]').trigger('click')
    
    expect(wrapper.find('.error-message').text()).toContain('email n\'est pas valide')
  })

  it('calls onSubmit prop when provided', async () => {
    const mockSubmit = vi.fn().mockResolvedValue({ success: true })
    const wrapper = mount(ContactForm, {
      props: { onSubmit: mockSubmit }
    })

    // Fill form with valid data
    await wrapper.find('#name').setValue('John Doe')
    await wrapper.find('#email').setValue('john@example.com')
    await wrapper.find('#subject').setValue('inscription')
    await wrapper.find('#message').setValue('Test message')

    await wrapper.find('button[type="submit"]').trigger('click')

    expect(mockSubmit).toHaveBeenCalledWith({
      name: 'John Doe',
      email: 'john@example.com',
      phone: '',
      subject: 'inscription',
      message: 'Test message'
    })
  })
})
```

## Tests E2E (Playwright)

### Configuration
```javascript
// playwright.config.js
import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
})
```

### Tests de Formulaire de Contact
```javascript
import { test, expect } from '@playwright/test'

test.describe('Contact Form', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/')
  })

  test('should open contact modal from hero button', async ({ page }) => {
    await page.click('text=Nous rejoindre')
    
    await expect(page.locator('.modal-overlay')).toBeVisible()
    await expect(page.locator('.modal-title')).toContainText('Nous contacter')
  })

  test('should validate required fields', async ({ page }) => {
    await page.click('text=Nous rejoindre')
    
    await page.click('button[type="submit"]')
    
    await expect(page.locator('.error-message')).toBeVisible()
    await expect(page.locator('input.error')).toBeVisible()
  })

  test('should submit form successfully with mocked API', async ({ page }) => {
    // Mock the API call
    await page.route('**/api/contact', async route => {
      await route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify({ success: true, message: 'Message sent successfully' })
      })
    })

    await page.click('text=Nous rejoindre')
    
    // Fill form with valid data
    await page.fill('#name', 'John Doe')
    await page.fill('#email', 'john@example.com')
    await page.fill('#phone', '06 12 34 56 78')
    await page.selectOption('#subject', 'inscription')
    await page.fill('#message', 'Je souhaite rejoindre le club CPBO')
    
    await page.click('button[type="submit"]')
    
    // Check success message
    await expect(page.locator('.submit-message.success')).toBeVisible()
    await expect(page.locator('.submit-message.success')).toContainText('envoyé avec succès')
  })
})
```

## Mocking et Stubbing

### Mock d'API
```javascript
// Mock d'API pour les tests
const mockApiResponse = {
  success: true,
  message: 'Message sent successfully'
}

// Dans les tests E2E
await page.route('**/api/contact', async route => {
  await route.fulfill({
    status: 200,
    contentType: 'application/json',
    body: JSON.stringify(mockApiResponse)
  })
})

// Dans les tests unitaires
const mockSubmit = vi.fn().mockResolvedValue(mockApiResponse)
```

### Mock de Composants
```javascript
// Mock d'un composant enfant
const mockChildComponent = {
  template: '<div>Mocked Child</div>'
}

const wrapper = mount(ParentComponent, {
  global: {
    components: {
      ChildComponent: mockChildComponent
    }
  }
})
```

## Bonnes Pratiques

### Tests Unitaires
- **Isolation** : Chaque test doit être indépendant
- **Arrange-Act-Assert** : Structure claire des tests
- **Noms descriptifs** : Les noms de tests doivent décrire le comportement
- **Mock des dépendances** : Éviter les appels réseau réels
- **Couverture complète** : Tester tous les chemins de code

### Tests E2E
- **Scénarios réalistes** : Tester des parcours utilisateur complets
- **Données de test** : Utiliser des données cohérentes
- **Attentes explicites** : Attendre les éléments avant les interactions
- **Nettoyage** : Réinitialiser l'état entre les tests
- **Performance** : Éviter les tests trop lents

### Maintenance
- **Tests maintenables** : Code de test lisible et modulaire
- **Documentation** : Commenter les tests complexes
- **Refactoring** : Mettre à jour les tests lors des changements
- **CI/CD** : Intégrer les tests dans le pipeline
- **Monitoring** : Surveiller la stabilité des tests

## Commandes de Test

```bash
# Tests unitaires
npm run test              # Lancer tous les tests
npm run test:ui           # Interface graphique
npm run test -- --watch   # Mode watch

# Tests E2E
npm run test:e2e          # Lancer les tests E2E
npx playwright test --ui  # Interface graphique
npx playwright test --debug # Mode debug

# Couverture
npm run test -- --coverage # Rapport de couverture
```